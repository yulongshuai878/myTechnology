# 01.Java IO

## 1、IO体系

从数据来源或者说是操作对象角度看，IO类可以分为：

1、文件（file）：FileInputStream、FileOutoutStream、FileReader、FileWriter

2、数组（[]）：

​		2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream

​		2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter

3、管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter

4、基本数据类型：DataInputStram、DataOutputStream

5、缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter

6、打印：PrintStream、PrintWriter

7、对象序列化反序列化：ObjectInputStream、ObjectOutputStream

8、转换：InputStreamReader、OutputStreamWriter

数据源节点也可以在进行二次处理，使数据更加容易使用，所以开可以划分成节点流和处理流，这里涉及到设计模式。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E6%8C%89%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%92%E5%88%86.png" />

从数据传输方式或运输方式角度看，可以将IO类分为：

- 字节流
- 字符流

字节流是以一个字节单位来运输的，比如一杯一杯的取水。而字符流是以多个字节来运输的，比如一桶一桶的取水，一桶水又可以分为几杯水。

字节流和字符流的区别：

字节流读取单个字节，字符流读取单个字符（一个字符根据编码的不同，对应的字节也不同，如UTF-8编码是3个字节，中文编码是2个字节）字节流用来处理二进制文件（图片、MP3、视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。简而言之，字节是给计算机看到，字符是给人看的。

字节流和字符流的划分：

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%88%92%E5%88%86.png" />

文件最基本的读写类File开头、文件读写带缓冲区的类Buffered尅头的类，对象序列化反序列化相关的类Object开头的类。

## 2、IO类和相关方法

**InputStream 类**

| 方法                                         | 方法介绍                                                     |
| -------------------------------------------- | ------------------------------------------------------------ |
| public abstract int read()                   | 读取数据                                                     |
| public int read(byte b[])                    | 将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度 |
| public int read(byte b[], int off, int len)  | 从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的（注意这里读取的虽然是一个字节，但是返回的却是 int 类型 4 个字节，这里当然是有原因，这里就不再细说了，推荐这篇文章，[链接](https://blog.csdn.net/congwiny/article/details/18922847)） |
| public long skip(long n)                     | 跳过指定个数的字节不读取，想想看电影跳过片头片尾             |
| public int available()                       | 返回可读的字节数量                                           |
| public void close()                          | 读取完，关闭流，释放资源                                     |
| public synchronized void mark(int readlimit) | 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断 |
| public synchronized void reset()             | 重置读取位置为上次 mark 标记的位置                           |
| public boolean markSupported()               | 判断当前流是否支持标记流，和上面两个方法配套使用             |

**OutputStream 类**

| 方法                                          | 方法介绍                                                     |
| --------------------------------------------- | ------------------------------------------------------------ |
| public abstract void write(int b)             | 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。 |
| public void write(byte b[])                   | 将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。 |
| public void write(byte b[], int off, int len) | 将 byte 数组从 off 位置开始，len 长度的字节写入              |
| public void flush()                           | 强制刷新，将缓冲中的数据写入                                 |
| public void close()                           | 关闭输出流，流被关闭后就不能再输出数据了                     |

再来看 Reader 和 Writer 类中的方法，你会发现和上面两个抽象基类中的方法很像。

| 方法                                                    | 方法介绍                                                     |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| public int read(java.nio.CharBuffer target)             | 读取字节到字符缓存中                                         |
| public int read()                                       | 读取单个字符                                                 |
| public int read(char cbuf[])                            | 读取字符到指定的 char 数组中                                 |
| abstract public int read(char cbuf[], int off, int len) | 从 off 位置读取 len 长度的字符到 char 数组中                 |
| public long skip(long n)                                | 跳过指定长度的字符数量                                       |
| public boolean ready()                                  | 和上面的 available() 方法类似                                |
| public boolean markSupported()                          | 判断当前流是否支持标记流                                     |
| public void mark(int readAheadLimit)                    | 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断 |
| public void reset()                                     | 重置读取位置为上次 mark 标记的位置                           |
| abstract public void close()                            | 关闭流释放相关资源                                           |

**Writer 类**

| 方法                                                       | 方法介绍                                                     |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| public void write(int c)                                   | 写入一个字符                                                 |
| public void write(char cbuf[])                             | 写入一个字符数组                                             |
| abstract public void write(char cbuf[], int off, int len)  | 从字符数组的 off 位置写入 len 数量的字符                     |
| public void write(String str)                              | 写入一个字符串                                               |
| public void write(String str, int off, int len)            | 从字符串的 off 位置写入 len 数量的字符                       |
| public Writer append(CharSequence csq)                     | 追加吸入一个字符序列                                         |
| public Writer append(CharSequence csq, int start, int end) | 追加写入一个字符序列的一部分，从 start 位置开始，end 位置结束 |
| public Writer append(char c)                               | 追加写入一个 16 位的字符                                     |
| abstract public void flush()                               | 强制刷新，将缓冲中的数据写入                                 |
| abstract public void close()                               | 关闭输出流，流被关闭后就不能再输出数据了                     |

### 2.1、读取控制台中的输入

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @program: main_model
 * @description:
 * @author: ShiYulong
 * @create: 2020-01-13 14:27
 **/
public class IoTest {
    public static void main(String[] args) throws IOException {
        // 三个测试方法
//        test01();
//        test02();
        test03();
    }

    public static void test01() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一个字符");
        char c;
        c = (char) bufferedReader.read();
        System.out.println("你输入的字符为"+c);
    }

    public static void test02() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一个字符，按 q 键结束");
        char c;
        do {
            c = (char) bufferedReader.read();
            System.out.println("你输入的字符为"+c);
        } while (c != 'q');
    }

    public static void test03() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一行字符");
        String str = bufferedReader.readLine();
        System.out.println("你输入的字符为" + str);
    }
}

```

2.2、二进制文件的写入和读取

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @program: main_model
 * @description:
 * @author: ShiYulong
 * @create: 2020-01-13 14:34
 **/
public class Iotest2 {
    public static void test04() throws IOException {
        byte[] bytes = {12,21,34,11,21};
        FileOutputStream fileOutputStream = new FileOutputStream(new File("").getAbsolutePath()+"/io/test.txt");
        // 写入二进制文件，直接打开会出现乱码
        fileOutputStream.write(bytes);
        fileOutputStream.close();
    }

    public static void test05() throws IOException {
        FileInputStream fileInputStream = new FileInputStream(new File("").getAbsolutePath() + "/io/test.txt");
        int c;
        // 读取写入的二进制文件，输出字节数组
        while ((c = fileInputStream.read()) != -1) {
            System.out.print(c);
        }
    }
    public static void main(String[] args) throws IOException {
        test04();
        test05();
    }
}
```

