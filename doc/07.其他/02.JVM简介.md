# 02.JVM简介

 JVM是Java Virtual Machine（Java虚拟机）的缩写。

## 一、JVM结构

主要有三个基本部分：类装载器（ClassLoader）子系统、运行时数据区和执行引擎。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE.png" />

### 1、类装载器

  负责加载程序中的class文件，管理并分配内存 。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8.png" />

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" />

### 2、执行引擎

  执行字节码或者执行本地方法

### 3、运行时数据区

  运行时JVM的内存支持

## 二、内存模型

Java虚拟机的内存空间分为5个部分，分别是：

1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" />

### 1、程序计数器

#### 1.1、什么是程序计数器

程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码的指令地址。

**注：**但是，如果当前线程正在执行的是一个本地方法（native修饰方法），那么此时程序计数器为空。

#### 1.2、程序计数器的作用

程序计数器有两个作用：

1. 读取指令，实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 多线程时，记录线程的执行位置。

#### 1.3、程序计数器的特点

1. 较小的存储空间
2. 线程私有，生命周期和线程一致。每条线程都有一个程序计数器。
3. 不会出现内存溢出（OutOfMemoryError）。

### 2、java虚拟机栈（JVM Stack）

java栈空间是一块线程私有的内存空间，和线程执行密切相关（java堆和程序数据密切相关）。线程最基本的执行行为就是函数的调用。每次函数调用其实是通过java栈传递数据的。

数据结构中的栈的特性：先进后出，后进先出。LIFO。

Java虚拟机栈会为每一个即将运行的java方法创建一块叫做“栈帧”的区域，每一次方法调用都会有对应的栈帧被压进java栈，执行反比的时候被弹出java栈，并释放内存空间。

栈帧包括：

1. 局部变量表：方法的参数以及局部的变量。
2. 操作数栈：保存计算过程的中间结果，同事作为计算过程中变量临时的存储空间。
3. 帧数据区：支持常量池解析，正常方法返回和异常处理。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" />

**注：**每一次函数调用生成栈帧，从而肯定会占用一定的栈空间。所以占空间内存不足的时候，函数调用无法进行。当请求的栈深度大于最大栈深度的时候系统会抛出StackOverflowError异常。

### 3、本地方法栈

本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法（native修饰方法）运行的内存模型。

方法执行完毕后相应的栈帧也会出栈并释放内存空间。

也会抛出StackOverflowError和OutOfMemoryError异常。

### 4、堆

#### 4.1、什么是堆？

堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。

#### 4.2、堆的特点

1. 线程共享：整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对用一个的。
2. 在虚拟机启动时创建。
3. 垃圾回收的主要场所。
4. 可以进一步细分为：新生代、老年代。新生代又可被分为：Eden区、Survior区。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
5. 对的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OuntOfMemoryError。

### 5、方法区

#### 5.1、什么是方法区？

Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

#### 5.2、方法区的特点

1. 线程共享：方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
2. 永久代：方法区中的信息一般需要长期存在，而且它又是堆的划分方法，我们把方法区称为永久代。
3. 内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是：对常量池的回收和对类型的卸载。
4. Java虚拟机规范对方法区的要求比较宽松：和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

#### 5.3、什么是运行时常量池

方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。

我们一般在一个类中通过public static final 来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。

当个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：Integer类的valueOf()方法就能在运行期间向常量池中添加Integer常量。

当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾回收器回收。

### 6、总结

1. Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部结构相同，都是线程私有。只不过Java虚拟机栈描述的是Java方法运行过成人的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。
2. Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。
3. 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。
4. 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法区。并在Java启动的时候就创建，Java停止才销毁，

## 三、垃圾回收机制(GC)

### 1、判断回收对象算法

#### 1.1、引用计数算法

给对象添加一个引用计数器，当有一个地方引用它时，计数值加1，当引用失效时，计数减1.计数为0的对象不可能再被使用，进行回收。

问题：很难解决对象直接相互循环应用问题，Java虚拟机未使用此算法。

#### 1.2、可达性分析算法

基本思想：通过一系列的成为“GC Roots”的对象作为起始点，从这个节点往下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相对时（路径不可达），则证明此对象不可用。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png" />

### 2、垃圾收集算法

#### 2.1、收集区域

垃圾回收机制是对JVM内存模型中堆和方法区中内存进行回收。堆分为新生代（Eden区、Survior区）、老年代（Old区），方法区也称永久代（Perm区）。

#### 2.2、GC分类

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.png" />

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代，因此GC按照回收的区域又分为两个类型，一种是普通的GC（minor GC），一种是全局GC（majar GC or Full GC）。

- 普通GC：只针对新生代区域的GC。
- 全局GC：针对老年代的GC。

#### 2.3、GC三大算法

- 复制算法（Copying）
- 标记清除算法/标记整理算法(Mark-Sweep)/(Mark-Compact)
- 分代收集(Generational Collection)

