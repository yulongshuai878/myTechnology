# 02.JVM简介

[TOC]

 JVM是Java Virtual Machine（Java虚拟机）的缩写。

## 一、JVM结构

主要有三个基本部分：类装载器（ClassLoader）子系统、运行时数据区和执行引擎。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE.png" />

### 1、类装载器

  负责加载程序中的class文件，管理并分配内存 。

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。



<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8.png" />

其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。

以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：

- 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候。
- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。
- 当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。
- 当使用 JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。
  

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" />

### 2、执行引擎

  执行字节码或者执行本地方法

### 3、运行时数据区

  运行时JVM的内存支持

## 二、内存模型

Java虚拟机的内存空间分为5个部分，分别是：

- 程序计数器
- Java虚拟机栈
- 本地方法栈
- 堆
- 方法区

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" />

### 1、程序计数器

#### 1.1、什么是程序计数器

程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码的指令地址。

**注：**但是，如果当前线程正在执行的是一个本地方法（native修饰方法），那么此时程序计数器为空。

#### 1.2、程序计数器的作用

程序计数器有两个作用：

- 读取指令，实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 多线程时，记录线程的执行位置。

#### 1.3、程序计数器的特点

- 较小的存储空间
- 线程私有，生命周期和线程一致。每条线程都有一个程序计数器。
- 不会出现内存溢出（OutOfMemoryError）。

### 2、java虚拟机栈（JVM Stack）

java栈空间是一块线程私有的内存空间，和线程执行密切相关（java堆和程序数据密切相关）。线程最基本的执行行为就是函数的调用。每次函数调用其实是通过java栈传递数据的。

数据结构中的栈的特性：先进后出，后进先出。LIFO。

Java虚拟机栈会为每一个即将运行的java方法创建一块叫做“栈帧”的区域，每一次方法调用都会有对应的栈帧被压进java栈，执行反比的时候被弹出java栈，并释放内存空间。

栈帧包括：

- 局部变量表：方法的参数以及局部的变量。
- 操作数栈：保存计算过程的中间结果，同事作为计算过程中变量临时的存储空间。
- 帧数据区：支持常量池解析，正常方法返回和异常处理。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" />

**注：**每一次函数调用生成栈帧，从而肯定会占用一定的栈空间。所以占空间内存不足的时候，函数调用无法进行。当请求的栈深度大于最大栈深度的时候系统会抛出StackOverflowError异常。

### 3、本地方法栈

本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法（native修饰方法）运行的内存模型。

方法执行完毕后相应的栈帧也会出栈并释放内存空间。

也会抛出StackOverflowError和OutOfMemoryError异常。

### 4、堆

#### 4.1、什么是堆？

堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。

#### 4.2、堆的特点

- 线程共享：整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对用一个的。
- 在虚拟机启动时创建。
- 垃圾回收的主要场所。
- 可以进一步细分为：新生代、老年代。新生代又可被分为：Eden区、Survior区。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
- 对的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OuntOfMemoryError。

### 5、方法区

#### 5.1、什么是方法区？

Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

#### 5.2、方法区的特点

- 线程共享：方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
- 永久代：方法区中的信息一般需要长期存在，而且它又是堆的划分方法，我们把方法区称为永久代。
- 内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是：对常量池的回收和对类型的卸载。
- Java虚拟机规范对方法区的要求比较宽松：和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

#### 5.3、什么是运行时常量池

方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。

我们一般在一个类中通过public static final 来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。

当个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：Integer类的valueOf()方法就能在运行期间向常量池中添加Integer常量。

当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾回收器回收。

### 6、总结

- Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部结构相同，都是线程私有。只不过Java虚拟机栈描述的是Java方法运行过成人的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。
- Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。
- 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。
- 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法区。并在Java启动的时候就创建，Java停止才销毁，

## 三、垃圾回收机制(GC)

### 1、判断回收对象算法

#### 1.1、引用计数算法

给对象添加一个引用计数器，当有一个地方引用它时，计数值加1，当引用失效时，计数减1.计数为0的对象不可能再被使用，进行回收。

问题：很难解决对象直接相互循环应用问题，Java虚拟机未使用此算法。

#### 1.2、可达性分析算法

基本思想：通过一系列的成为“GC Roots”的对象作为起始点，从这个节点往下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相对时（路径不可达），则证明此对象不可用。

可作为 GC Roots 的对象：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png" />

下面四种引用强度一次逐渐减弱

- 强引用

  类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。

- 软引用

  SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。

- 弱引用

  WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。

- 虚引用

  PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 2、垃圾收集算法

#### 2.1、收集区域

垃圾回收机制是对JVM内存模型中堆和方法区中内存进行回收。堆分为新生代（Eden区、Survior区）、老年代（Old区），方法区也称永久代（Perm区）。

#### 2.2、GC分类

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.png" />

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代，因此GC按照回收的区域又分为两个类型，一种是普通的GC（minor GC），一种是全局GC（majar GC or Full GC）。

- 普通GC：只针对新生代区域的GC。
- 全局GC：针对老年代的GC。

在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。

永久代垃圾回收主要两部分内容：废弃的常量和无用的类。

判断废弃常量：一般是判断没有该常量的引用。

判断无用的类：要以下三个条件都满足:

- 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法

#### 2.3、GC三大算法

- 复制算法（Copying）
- 标记清除算法/标记整理算法(Mark-Sweep)/(Mark-Compact)
- 分代收集(Generational Collection)

##### 2.3.1、复制算法

- 年轻代中使用的是普通GC采用的是复制算法

- 原理：复制算法将新生代分为Eden区，Survivor1区（From区）、Survivor（To区），当Eden区内存已满后触发Minor GC，其中的对象如果存活将会被复制到To区，且对象年龄加1，当年两增加到一定程度时，就会被移动到年老代中。Eden区和From区被清空，From区和To区交换他们的角色，保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" />

第一次GC，当Eden区满后，系统检查所有的存活对象，并将这些存活对象整理之后移动到SD区。

第二次GC，当Eden区被填满后，系统检查Eden区&S0区的所有存活对象，并将这些存活对象整理之后移动到S1区。

- 空间分配比例：（Eden区：From区：To区）为（8:1:1）。

  因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空间和活动区间，而另外80%的内存，则是用来给新建对象分配内存，一旦发生GC，将10%的活动区间与另外80%中存活的对象转移到10%的内存区间，接下来，将之前90%的内存全部释放，以此类推。

##### 2.3.2、标记清除算法/标记整理算法

年老代一般由标记清除或者标记清除与标记整理一起实现。

- 标记清除算法（Mark-Sweep）

  <img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" />

1. 标记（Mark）：从根集合开始扫描，对存活的对象进行标记。

2. 清除（Sweep）：扫描整个内存空间，回收未被标记的对象，使用free-list记录。

   两个不足：

   1. 效率不高
   2. 空间会产生大量碎片

- 标记整理算法（Mark-Compact）

  标记整理算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理多端边界以外的内存。

  不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

  <img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" />

##### 2.3.3、复制算法和标记清除算法、标记整理算法对比

- 内存效率：复制算法 > 标记清除算法 > 标记整理算法
- 内存整齐度：复制算法 = 标记整理算法 > 标记清除算法
- 内存利用率：标记整理算法 = 标记清除算法 > 复制算法

复制算法由于浪费了大量空间用于复制存储，内存利用率低；标记整理算法需要标记所有的存活对象，整理所有村呼呼对象引用的地址、内存效率低。

2.3.4、分代收集算法（Generational Collection）

根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

- 新生代

  每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。

- 老年代

  老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。

注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的挥挥手主要回收两部分内容：废弃常量和无用的类。

### 3、垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实现。基于JDK1.7之前的HotSpot

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/HotSpot.png" />

说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。

#### 3.1、Serial收集器

这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" />

#### 3.2、ParNew 收集器

可以认为是 Serial 收集器的多线程版本。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" />

- 并行：Parallel

  指多条垃圾收集线程并行工作，此时用户线程处于等待状态

- 并发：Concurrent

  指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。

#### 3.3、Parallel Scavenge 收集器

这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。

CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。

作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。

#### 3.4、Serial Old 收集器

收集器的老年代版本，单线程，使用 **标记 —— 整理**。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Serial%20Old%E6%94%B6%E9%9B%86%E5%99%A8.png" />

#### 3.5、Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 **标记 —— 整理**

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Parallel%20Scavenge.png" />

#### 3.6、CMS 收集器

CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 **标记 —— 清除** 算法实现。

运作步骤:

1. 初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象
2. 并发标记(CMS concurrent mark)：进行 GC Roots Tracing
3. 重新标记(CMS remark)：修正并发标记期间的变动部分
4. 并发清除(CMS concurrent sweep)

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/CMS%E7%AE%97%E6%B3%95.png" />

缺点：对 CPU 资源敏感、无法收集浮动垃圾、**标记 —— 清除** 算法带来的空间碎片

#### 3.7、G1 收集器

面向服务端的垃圾回收器。

**优点：**并行与并发、分代收集、空间整合、可预测停顿。

运作步骤:

1. 初始标记(Initial Marking)
2. 并发标记(Concurrent Marking)
3. 最终标记(Final Marking)
4. 筛选回收(Live Data Counting and Evacuation)

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" />

## 四、内存分配与回收策略

### 1、对象优先在 Eden 分配

对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。

一般来说 Java 堆的内存模型如下图所示：

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" />

- 新生代 GC (Minor GC)

  发生在新生代的垃圾回收动作，频繁，速度快。

- 老年代 GC (Major GC / Full GC)

  发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。

### 2、大对象直接进入老年代

### 3、长期存活的对象将进入老年代

### 4、 动态对象年龄判定

### 5、空间分配担保

## 五、Java内存模型与线程

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" />

### 1、Java内存模型

屏蔽掉各种硬件和操作系统的内存访问差异。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" />

#### 1.1、主内存和工作内存之间的交互

| 操作   | 作用对象 | 解释                                                         |
| ------ | -------- | ------------------------------------------------------------ |
| lock   | 主内存   | 把一个变量标识为一条线程独占的状态                           |
| unlock | 主内存   | 把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定   |
| read   | 主内存   | 把一个变量的值从主内存传输到线程工作内存中，以便load操作使用 |
| load   | 工作内存 | 把read操作从主内存中得到的变量值放入工作内存中               |
| use    | 工作内存 | 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作 |
| assign | 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行此操作 |
| store  | 工作内存 | 把工作内存中的一个变量的值传输到主内存中，以便write操作      |
| write  | 工作内存 | 把store操作从工作内存中得到的变量的值放入主内存的变量        |

#### 1.2、对于 volatile 型变量的特殊规则

关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。

一个变量被定义为 volatile 的特性：

- 保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。

  如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值和 变量不需要与其他的状态变量共同参与不变约束就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。

- 禁止指令重排序优化。

  通过插入内存屏障保证一致性。

#### 1.3、对于double和long型变量的特殊规则

Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。

#### 1.4、原子性、可见性与有序性

- 原子性(Atomicity)

  由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。

- 可见性(Visibility)

  是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。

- 有序性(Ordering)

  如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。

2、先行发生原则

也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。

天然的先行发生关系

| 规则             | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| 程序次序规则     | 在一个线程内，代码按照书写的控制流顺序执行                   |
| 管程锁定规则     | 一个unlock操作先行发生于后面对同一个锁的lock操作             |
| volatile变量规则 | volatile变量的写操作先行发生于后面对这个变量的度操作         |
| 线程启动规则     | Thread对象的start()方法先行发生于此线程的每一个动作          |
| 线程终止规则     | 线程中所有的操作都先行发生于对此线程的终止检测（通过Thread.join()方法结束、Thread.isAlive()的返回值检测） |
| 线程中断规则     | 对线程interrupt()方法调用有限发生于被中断线程的大妈检测到中断事件的发生（通过Thread.interrupted()方法检测） |
| 对象终结规则     | 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始 |
| 传递性           | 如果操作A先于操作B发生，操作B先于操作C发生，那么操作A先于操作C |

### 2、Java与线程

#### 2.1、线程的实现

平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。

##### 2.1.1、使用内核线程实现

直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.png" />

##### 2.1.2、使用用户线程实现

广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.png" />

##### 2.1.3、使用用户线程加轻量级进程混合实现

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.png" />

#### 2.2、线程的调度

- 协同式线程调度

  线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。

- 抢占式线程调度

  每个线程由系统来分配执行时间。

#### 2.3、状态转换

五种状态：

- 新建(new)

  创建后尚未启动的线程。

- 运行(Runable)

  Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。

- 无限期等待(Waiting)

  出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。

  以下方法会让线程进入无限期等待状态：

  1.没有设置 Timeout 参数的 Object.wait() 方法。
  2.没有设置 Timeout 参数的 Thread.join() 方法。
  3.LookSupport.park() 方法。

- 限期等待(Timed Waiting)

  处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。

  以下方法会让线程进入限期等待状态：
  1.Thread.sleep() 方法。
  2.设置了 Timeout 参数的 Object.wait() 方法。
  3.设置了 Timeout 参数的 Thread.join() 方法。
  4.LockSupport.parkNanos() 方法。
  5.LockSupport.parkUntil() 方法。

- 阻塞(Blocked)

  线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

- 结束(Terminated)

  已终止线程的线程状态。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" />

## 六、类的加载过程

### 1、加载

1. 通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。

数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：

1. 如果数组的组件类型是引用类型，那就递归采用类加载加载。
2. 如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。
3. 数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。

内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。

### 2、验证

是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。

#### 2.1、文件格式验证

1. 是否以魔数 0xCAFEBABE 开头
2. 主、次版本号是否在当前虚拟机处理范围之内
3. 常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）
4. 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
5. CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据
6. Class 文件中各个部分集文件本身是否有被删除的附加的其他信息
7. ……

只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。

#### 2.2、元数据验证

1. 这个类是否有父类（除 java.lang.Object 之外）
2. 这个类的父类是否继承了不允许被继承的类（final 修饰的类）
3. 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
4. 类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）

这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。

#### 2.3、字节码验证

1. 保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）
2. 保证跳转指令不会跳转到方法体以外的字节码指令上
3. 保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）
4. ……

这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。

2.4、符号引用验证

1. 符号引用中通过字符创描述的全限定名是否能找到对应的类
2. 在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段
3. 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问
4. ……

最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。
符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。

### 3、准备

这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。

public static int value = 1127;

这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。

基本数据类型的零值

| 数据类型 | 零值     | 数据类型  | 零值  |
| -------- | -------- | --------- | ----- |
| int      | 0        | boolean   | false |
| long     | 0L       | float     | 0.0f  |
| short    | (short)0 | double    | 0.0d  |
| char     | '\u0000' | reference | null  |
| byte     | (byte)0  |           |       |

特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。

### 4、解析

这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

1. 符号引用
   符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。
2. 直接引用
   直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。

### 5、初始化

前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。

### 6、类加载器

通过一个类的全限定名来获取描述此类的二进制字节流。

### 7、双亲委派模型

从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）

1. 启动类加载器
   加载 lib 下或被 -Xbootclasspath 路径下的类
2. 扩展类加载器
   加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类
3. 引用程序类加载器
   ClassLoader负责，加载用户路径上所指定的类库。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8E%9F%E5%88%99.png" />

### 8、破坏双亲委派模型

keyword：线程上下文加载器(Thread Context ClassLoader)