# 02.JVM简介

 JVM是Java Virtual Machine（Java虚拟机）的缩写。

## 一、JVM结构

主要有三个基本部分：类装载器（ClassLoader）子系统、运行时数据区和执行引擎。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE.png" />

### 1、类装载器

  负责加载程序中的class文件，管理并分配内存 。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%99%A8.png" />

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" />

### 2、执行引擎

  执行字节码或者执行本地方法

### 3、运行时数据区

  运行时JVM的内存支持

## 二、内存模型

Java虚拟机的内存空间分为5个部分，分别是：

1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" />

### 1、程序计数器

#### 1.1、什么是程序计数器

程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码的指令地址。

**注：**但是，如果当前线程正在执行的是一个本地方法（native修饰方法），那么此时程序计数器为空。

#### 1.2、程序计数器的作用

程序计数器有两个作用：

1. 读取指令，实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 多线程时，记录线程的执行位置。

#### 1.3、程序计数器的特点

1. 较小的存储空间
2. 线程私有，生命周期和线程一致。每条线程都有一个程序计数器。
3. 不会出现内存溢出（OutOfMemoryError）。

### 2、java虚拟机栈（JVM Stack）

java栈空间是一块线程私有的内存空间，和线程执行密切相关（java堆和程序数据密切相关）。线程最基本的执行行为就是函数的调用。每次函数调用其实是通过java栈传递数据的。

数据结构中的栈的特性：先进后出，后进先出。LIFO。

Java虚拟机栈会为每一个即将运行的java方法创建一块叫做“栈帧”的区域，每一次方法调用都会有对应的栈帧被压进java栈，执行反比的时候被弹出java栈，并释放内存空间。

栈帧包括：

1. 局部变量表：方法的参数以及局部的变量。
2. 操作数栈：保存计算过程的中间结果，同事作为计算过程中变量临时的存储空间。
3. 帧数据区：支持常量池解析，正常方法返回和异常处理。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" />

**注：**每一次函数调用生成栈帧，从而肯定会占用一定的栈空间。所以占空间内存不足的时候，函数调用无法进行。当请求的栈深度大于最大栈深度的时候系统会抛出StackOverflowError异常。

### 3、本地方法栈

本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法（native修饰方法）运行的内存模型。

方法执行完毕后相应的栈帧也会出栈并释放内存空间。

也会抛出StackOverflowError和OutOfMemoryError异常。

### 4、堆

#### 4.1、什么是堆？

堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。

#### 4.2、堆的特点

1. 线程共享：整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对用一个的。
2. 在虚拟机启动时创建。
3. 垃圾回收的主要场所。
4. 可以进一步细分为：新生代、老年代。新生代又可被分为：Eden区、Survior区。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
5. 对的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OuntOfMemoryError。

### 5、方法区

#### 5.1、什么是方法区？

Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

#### 5.2、方法区的特点

1. 线程共享：方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
2. 永久代：方法区中的信息一般需要长期存在，而且它又是堆的划分方法，我们把方法区称为永久代。
3. 内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是：对常量池的回收和对类型的卸载。
4. Java虚拟机规范对方法区的要求比较宽松：和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。

#### 5.3、什么是运行时常量池

方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。

我们一般在一个类中通过public static final 来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。

当个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：Integer类的valueOf()方法就能在运行期间向常量池中添加Integer常量。

当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾回收器回收。

### 6、总结

1. Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部结构相同，都是线程私有。只不过Java虚拟机栈描述的是Java方法运行过成人的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。
2. Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。
3. 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。
4. 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法区。并在Java启动的时候就创建，Java停止才销毁，

## 三、垃圾回收机制(GC)

### 1、判断回收对象算法

#### 1.1、引用计数算法

给对象添加一个引用计数器，当有一个地方引用它时，计数值加1，当引用失效时，计数减1.计数为0的对象不可能再被使用，进行回收。

问题：很难解决对象直接相互循环应用问题，Java虚拟机未使用此算法。

#### 1.2、可达性分析算法

基本思想：通过一系列的成为“GC Roots”的对象作为起始点，从这个节点往下搜索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相对时（路径不可达），则证明此对象不可用。

可作为 GC Roots 的对象：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png" />

下面四种引用强度一次逐渐减弱

1. 强引用

   类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。

2. 软引用

   SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。

3. 弱引用

   WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。

4. 虚引用

   PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 2、垃圾收集算法

#### 2.1、收集区域

垃圾回收机制是对JVM内存模型中堆和方法区中内存进行回收。堆分为新生代（Eden区、Survior区）、老年代（Old区），方法区也称永久代（Perm区）。

#### 2.2、GC分类

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.png" />

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代，因此GC按照回收的区域又分为两个类型，一种是普通的GC（minor GC），一种是全局GC（majar GC or Full GC）。

- 普通GC：只针对新生代区域的GC。
- 全局GC：针对老年代的GC。

在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。

永久代垃圾回收主要两部分内容：废弃的常量和无用的类。

判断废弃常量：一般是判断没有该常量的引用。

判断无用的类：要以下三个条件都满足:

1. 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例
2. 加载该类的 ClassLoader 已经被回收
3. 该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法

#### 2.3、GC三大算法

- 复制算法（Copying）
- 标记清除算法/标记整理算法(Mark-Sweep)/(Mark-Compact)
- 分代收集(Generational Collection)

##### 2.3.1、复制算法

- 年轻代中使用的是普通GC采用的是复制算法

- 原理：复制算法将新生代分为Eden区，Survivor1区（From区）、Survivor（To区），当Eden区内存已满后触发Minor GC，其中的对象如果存活将会被复制到To区，且对象年龄加1，当年两增加到一定程度时，就会被移动到年老代中。Eden区和From区被清空，From区和To区交换他们的角色，保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" />

第一次GC，当Eden区满后，系统检查所有的存活对象，并将这些存活对象整理之后移动到SD区。

第二次GC，当Eden区被填满后，系统检查Eden区&S0区的所有存活对象，并将这些存活对象整理之后移动到S1区。

- 空间分配比例：（Eden区：From区：To区）为（8:1:1）。

  因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空间和活动区间，而另外80%的内存，则是用来给新建对象分配内存，一旦发生GC，将10%的活动区间与另外80%中存活的对象转移到10%的内存区间，接下来，将之前90%的内存全部释放，以此类推。

##### 2.3.2、标记清除算法/标记整理算法

年老代一般由标记清除或者标记清除与标记整理一起实现。

- 标记清除算法（Mark-Sweep）

  <img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" />

1. 标记（Mark）：从根集合开始扫描，对存活的对象进行标记。

2. 清除（Sweep）：扫描整个内存空间，回收未被标记的对象，使用free-list记录。

   两个不足：

   1. 效率不高
   2. 空间会产生大量碎片

- 标记整理算法（Mark-Compact）

  标记整理算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理多端边界以外的内存。

  不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

  <img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" />

##### 2.3.3、复制算法和标记清除算法、标记整理算法对比

1. 内存效率：复制算法 > 标记清除算法 > 标记整理算法
2. 内存整齐度：复制算法 = 标记整理算法 > 标记清除算法
3. 内存利用率：标记整理算法 = 标记清除算法 > 复制算法

复制算法由于浪费了大量空间用于复制存储，内存利用率低；标记整理算法需要标记所有的存活对象，整理所有村呼呼对象引用的地址、内存效率低。

2.3.4、分代收集算法（Generational Collection）

根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

- 新生代

  每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。

- 老年代

  老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。

注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的挥挥手主要回收两部分内容：废弃常量和无用的类。

### 3、垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实现。基于JDK1.7之前的HotSpot

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/HotSpot.png" />

#### 3.1、Serial收集器

这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/07.JVM/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" />

