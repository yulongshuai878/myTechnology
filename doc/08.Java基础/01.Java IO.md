# 01.Java IO

## 1、IO体系

从数据来源或者说是操作对象角度看，IO类可以分为：

1、文件（file）：FileInputStream、FileOutoutStream、FileReader、FileWriter

2、数组（[]）：

​		2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream

​		2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter

3、管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter

4、基本数据类型：DataInputStram、DataOutputStream

5、缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter

6、打印：PrintStream、PrintWriter

7、对象序列化反序列化：ObjectInputStream、ObjectOutputStream

8、转换：InputStreamReader、OutputStreamWriter

数据源节点也可以在进行二次处理，使数据更加容易使用，所以开可以划分成节点流和处理流，这里涉及到设计模式。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E6%8C%89%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%92%E5%88%86.png" />

从数据传输方式或运输方式角度看，可以将IO类分为：

- 字节流
- 字符流

字节流是以一个字节单位来运输的，比如一杯一杯的取水。而字符流是以多个字节来运输的，比如一桶一桶的取水，一桶水又可以分为几杯水。

字节流和字符流的区别：

字节流读取单个字节，字符流读取单个字符（一个字符根据编码的不同，对应的字节也不同，如UTF-8编码是3个字节，中文编码是2个字节）字节流用来处理二进制文件（图片、MP3、视频文件），字符流用来处理文本文件（可以看做是特殊的二进制文件，使用了某种编码，人可以阅读）。简而言之，字节是给计算机看到，字符是给人看的。

字节流和字符流的划分：

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%88%92%E5%88%86.png" />

文件最基本的读写类File开头、文件读写带缓冲区的类Buffered尅头的类，对象序列化反序列化相关的类Object开头的类。

## 2、IO类和相关方法

**InputStream 类**

| 方法                                         | 方法介绍                                                     |
| -------------------------------------------- | ------------------------------------------------------------ |
| public abstract int read()                   | 读取数据                                                     |
| public int read(byte b[])                    | 将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度 |
| public int read(byte b[], int off, int len)  | 从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的（注意这里读取的虽然是一个字节，但是返回的却是 int 类型 4 个字节，这里当然是有原因，这里就不再细说了，推荐这篇文章，[链接](https://blog.csdn.net/congwiny/article/details/18922847)） |
| public long skip(long n)                     | 跳过指定个数的字节不读取，想想看电影跳过片头片尾             |
| public int available()                       | 返回可读的字节数量                                           |
| public void close()                          | 读取完，关闭流，释放资源                                     |
| public synchronized void mark(int readlimit) | 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断 |
| public synchronized void reset()             | 重置读取位置为上次 mark 标记的位置                           |
| public boolean markSupported()               | 判断当前流是否支持标记流，和上面两个方法配套使用             |

**OutputStream 类**

| 方法                                          | 方法介绍                                                     |
| --------------------------------------------- | ------------------------------------------------------------ |
| public abstract void write(int b)             | 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。 |
| public void write(byte b[])                   | 将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。 |
| public void write(byte b[], int off, int len) | 将 byte 数组从 off 位置开始，len 长度的字节写入              |
| public void flush()                           | 强制刷新，将缓冲中的数据写入                                 |
| public void close()                           | 关闭输出流，流被关闭后就不能再输出数据了                     |

再来看 Reader 和 Writer 类中的方法，你会发现和上面两个抽象基类中的方法很像。

| 方法                                                    | 方法介绍                                                     |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| public int read(java.nio.CharBuffer target)             | 读取字节到字符缓存中                                         |
| public int read()                                       | 读取单个字符                                                 |
| public int read(char cbuf[])                            | 读取字符到指定的 char 数组中                                 |
| abstract public int read(char cbuf[], int off, int len) | 从 off 位置读取 len 长度的字符到 char 数组中                 |
| public long skip(long n)                                | 跳过指定长度的字符数量                                       |
| public boolean ready()                                  | 和上面的 available() 方法类似                                |
| public boolean markSupported()                          | 判断当前流是否支持标记流                                     |
| public void mark(int readAheadLimit)                    | 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断 |
| public void reset()                                     | 重置读取位置为上次 mark 标记的位置                           |
| abstract public void close()                            | 关闭流释放相关资源                                           |

**Writer 类**

| 方法                                                       | 方法介绍                                                     |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| public void write(int c)                                   | 写入一个字符                                                 |
| public void write(char cbuf[])                             | 写入一个字符数组                                             |
| abstract public void write(char cbuf[], int off, int len)  | 从字符数组的 off 位置写入 len 数量的字符                     |
| public void write(String str)                              | 写入一个字符串                                               |
| public void write(String str, int off, int len)            | 从字符串的 off 位置写入 len 数量的字符                       |
| public Writer append(CharSequence csq)                     | 追加吸入一个字符序列                                         |
| public Writer append(CharSequence csq, int start, int end) | 追加写入一个字符序列的一部分，从 start 位置开始，end 位置结束 |
| public Writer append(char c)                               | 追加写入一个 16 位的字符                                     |
| abstract public void flush()                               | 强制刷新，将缓冲中的数据写入                                 |
| abstract public void close()                               | 关闭输出流，流被关闭后就不能再输出数据了                     |

### 2.1、读取控制台中的输入

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @program: main_model
 * @description:
 * @author: ShiYulong
 * @create: 2020-01-13 14:27
 **/
public class IoTest {
    public static void main(String[] args) throws IOException {
        // 三个测试方法
//        test01();
//        test02();
        test03();
    }

    public static void test01() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一个字符");
        char c;
        c = (char) bufferedReader.read();
        System.out.println("你输入的字符为"+c);
    }

    public static void test02() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一个字符，按 q 键结束");
        char c;
        do {
            c = (char) bufferedReader.read();
            System.out.println("你输入的字符为"+c);
        } while (c != 'q');
    }

    public static void test03() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入一行字符");
        String str = bufferedReader.readLine();
        System.out.println("你输入的字符为" + str);
    }
}

```

2.2、二进制文件的写入和读取

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @program: main_model
 * @description:
 * @author: ShiYulong
 * @create: 2020-01-13 14:34
 **/
public class Iotest2 {
    public static void test04() throws IOException {
        byte[] bytes = {12,21,34,11,21};
        FileOutputStream fileOutputStream = new FileOutputStream(new File("").getAbsolutePath()+"/io/test.txt");
        // 写入二进制文件，直接打开会出现乱码
        fileOutputStream.write(bytes);
        fileOutputStream.close();
    }

    public static void test05() throws IOException {
        FileInputStream fileInputStream = new FileInputStream(new File("").getAbsolutePath() + "/io/test.txt");
        int c;
        // 读取写入的二进制文件，输出字节数组
        while ((c = fileInputStream.read()) != -1) {
            System.out.print(c);
        }
    }
    public static void main(String[] args) throws IOException {
        test04();
        test05();
    }
}
```

## 3、Java IO和NIO

block IO与Non-block IO

| IO模型 | IO               | NIO                       |
| ------ | ---------------- | ------------------------- |
| 方式   | 从硬盘到内存     | 从内存到硬盘              |
| 通信   | 面向流           | 面向缓存                  |
| 处理   | 阻塞IO（多线程） | 非阻塞IO（反应堆Reactor） |
| 出发   | 无               | 选择器（轮询机制）        |

基本概念：

1、Java IO 方式有哪些？

- 传统java.io包：对文件进行了抽象、通过输入流输出流进行IO
- java.net包：网络通信同样是IO行为
- java.nio包：Java1.4中引入了NIO框架
- java7的NIO2：引入了异步非阻塞IO方式

2、按照阻塞方式分类

- BIO：同步、阻塞
- NIO：同步、非阻塞
- NIO2/AIO：异步、非阻塞

3、传统java.io包中的IO有什么特点？

- 基于stream模型实现
- 提供了常见的IO功能：File抽象、输入输出流
- 交互方式：同步：阻塞的方式
- 在读写动作完成前，线程会一直阻塞在那里，他们之间的调用时可靠的线性顺序

4、Stream(流)到底是什么？有什么用？

- Out：代表能产出数据的数据源对象
- In：代表能接受数据的数据源对象
- 作用：为数据源和目的地搭建一个传输通道

5、java.io包的优点和缺点

- 优点：代码简单、直观
- 缺点：IO效率、扩展性存在局限性，会成为应用性能的瓶颈

6、java.net下的网络通信的IO行为

- java.net下的网络API：Socket、ServerSocket、HttpURLConnection
- 这些也都属于同步阻塞IO类库

7、NIO框架是什么？

- Java1.4中引入
- 位于java.nio包
- 提供 Channel、Selector、Buffer等新的抽象

8、NIO的特点

- 可以构建多路复用的、同步非阻塞IO程序
- 同事供了更接近操作系统底层的高性能数据操作方式

9、NIO2或者AIO是什么？

- NIO 2，又称AIO（Asynchronous IO）
- 在Java 7中，对NIO进一步改进
- 引入了异步非阻塞IO方式
- 异步IO操作基于事件和回调机制——应用操作直接返回，而不会阻塞，当后台处理完成后，操作系统会通知相应线程进行后续工作。

10、NIO和IO相比性能优势在于哪里？

- IO面向流，从Stream中逐步读取数据，并且没有缓冲区。
- NIO面向缓冲区，数据整体操作更加高效
- IO是阻塞的，当前线程在没有数据可读时会出现阻塞
- NIO是非阻塞的，通过Selector选择器选择合适的Channel进行数据操作。当一个Channel没有数据时，会切换到有效的Channel处理其他IO，更高效

11、NIO的性能就一定比IO高？如果是带缓冲的IO和NIO相比呢？

- 传统的IO理论上是没有NIO快的；用IO进行一个字节一个字节的读取
- 但是如果合理使用，如带缓冲区的IO（BufferedInputStream、BufferedReader）时会很快
- 此外根据测试在进行文件拷贝等IO操作是，会发现NIO并没有比IO更快，甚至在个别场景还会出现NIO更慢的情况
- IBM官方指明：JDK1.4时已经将java.io以nio为基础重新进行实现，可以利用一些NIO的特点，因此处理方面的性能并不比NIO差

12、NIO的真正优势并不是体现在速度上？

- 随着JDK1.4对IO进行了重构。NIO在速度上的优势并不存在了。
- NIO的真正优势体现在：
  - ​	分在和聚集：利用Scanner/Gather委托操作系统完成数据分散和聚集的工作
  - ​	文件锁定功能
  - ​	网络异步IO：非阻塞IO、IO多路复用（解决服务端多线程时的线程占用问题）

## 4、同步和异步

同步和异步都是基于应用程序私操作系统处理IO事件所采用的方式，比如同步：是应用程序要直接参与IO读写的操作。异步：所有的IO读写交给搡作系统去处理，应用程序只需要等待通知。

同步方式在处理IO事件的时候，必须阻塞在某个方法上靣等待我们的IO事件完成(阻塞IO事件或者通过轮询IO事件的方式）.对于异步来说，所有的IO读写都交给了搡作系统。这个时候，我们可以去做其他的事情，并不拓要去完成真正的IO搡作，当搡作完成IO后.会给我们的应用程序一个通知

同步：阻塞到IO事件，阻塞到read成则write。这个时候我们就完全不能做自己的事情，让读写方法加入到线程里面，然后阻塞线程来实现，对线程的性能开销比较大，

13、同步和异步的区别？

- 同步——synchronous
- 异步——asynchronous
- 同步是一种可靠的有序运行机制，同步操作时，后续的任务会等待当前调用的返回
- 异步中，其他任务不会等待当前调用的返回，通常依靠事件、回调等机制来实现任务间次序关系

## 5、阻塞和非阻塞

阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式，当数据没有准备的时候阻塞：往往需要等待缞冲区中的数据准备好过后才处理其他的事情，否則一直等待在那里。

非阻塞：当我们的进程访问我们的数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据已经准备好，也直接返回

14、阻塞和非阻塞的区别？

- 阻塞——blocking
- 非阻塞——non-blocking
- 阻塞操作时，当前线程会处于阻塞状态，无法进行其他任务，只有当满足一定条件时，才继续执行
- 非阻塞状态，不会去等待IO操作结束，会立即返回。相应操作会在后台处理

15、阻塞和同步就是低效的操作？

错误！需要根据应用的实际场景。有些时候必须要进行阻塞和同步。

## 6、IO/BIO(32)

BIO从一个阻塞的流中一行一行的读取数据

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/BIO.png" />

1、传统IO操作就是指对文件进行操作？

错误！

- 文件操作是IO操作
- 网络编程中，如Socket通信，都是经典的IO操作

2、IO流是什么？有什么用？

- Input流和Output流
- 主要用于处理设备间的数据传输

3、IO流的两种分类方式

- 字节流和字符流
- 输入流和输出流

4、字节流的抽象基类

- InputStream
- OutputStream

5、字符流的抽象基类

- Reader
- Writer

6、字符流中融合了编码表

- 系统默认的已办采用GBK

7字符流与字节流的区别

- 处理对象不同：
  1. 字节流能处理所有类型的数据（如图片、多媒体等）
  2. 字符流只能处理字符类型的文本数据
- 读取单位不同：
  1. 字节流以字节byte为单位，1Byte=8bit
  2. 字符流以字符为单位，1个字符=2个字节（java中采用Unicode编码）。根据码表映射字符，一次有个读多个字节。
- 有无缓冲区：
  1. 字节流没有缓冲区，是直接输出的。字节流不调用close()方法时，信息就已经输出了。
  2. 字符流是输出到缓冲区的。只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法。

8、字符流让信息输出的两种方法

- close()关闭缓冲区时，信息会输出
- 手动调用flush()来输出信息

9、字符流和字节流如何选择？

- 只要是处理纯文本数据，就优先考虑使用字符流
- 除此之外都是用字节流

10、Closeable接口

- 很多IO工具类都实现了Closeable接口，因为需要进行资源的释放。
- 需要用try-with-resources、try-finally等机制保证资源被释放
- Cleaner或finalize机制作为资源释放的最后把关、也是必要的

11、Java传统IO相关的类图

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/Java%E4%BC%A0%E7%BB%9FIO%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE.png" />

12、java.io包中六大类和接口

- File、RandomAccessFile、InputStream、OutputStream、Reader、Writer
- Serializable

13、InputStream/OutputStream和Reader/Writer的关系和区别

- 都实现了Closeable接口，用于资源的释放
- 字节流：InputStream/OutputStream
- 字符流：Reader/Writer

14、java I/O主要的三个部分

- 流式部分-IO主体部分
- 非流式部分-一些辅助流程部分的类：File、RandomAccessFile、FileDescriptor
- 其他类-文件读取部分、安全相关的类

## 7、File

15、File类

- 采用File文件作为类名并不准确
- 本质上是文件路径，使用FilePath会更准确

16、创建的新文件，为什么只有很少的内容，也会占据几KB？

- 操作系统有最小分配空间

17、不同文件的开头会包含改文件类型相关信息

18、文件的创建

```java
//创建文件
File file = new File("d:\\a.txt");
if(file.exists() == false)
{
    file.createNewFile();
}
```

19、文件夹的创建

```java
//创建文件夹
File fileFolder = new File("d:\\New Folder");
if(fileFolder.isDirectory() == false)
{
    fileFolder.mkdir(); //创建folders
}
```

20、列出文件夹内所有文件

```java
//列出所有文件
File fileFolder = new File("d:\\New Folder");
if(fileFolder.isDirectory() == false)
{
    File []files = fileFolder.listFiles();
    for (File file : files) {
        file.getName();
    }
}
```

## 8、RandomAccessFile

21、RandomAccessFile是什么？

- 随机文件操作
- 一个独立的类，直接继承至Object
- 功能丰富，可以从文件的任意位置进行读取（输入输出）操作

## 9、InputStream

22、输入流和输出流的作用？

- InputStream/OutputStream
- 适用于读取或写入字节的，例如操作图片文件

23、FileInputStream的注意到

- 打开FileInputStream，会获取相应的文件描述符（FileDescriptor）
- 需要利用try-with-resources、try-finally等机制保证FileInputStream被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放

## 10、FileInputStream

24、FileInputStream读取文件中的数据

```java
  // 1、创建文件
        File file = new File("d:\\a.txt");
        // 2、创建输入流(字节流)
        FileInputStream fileInputStream = new FileInputStream(file);
        byte[] bytes = new byte[1024];
        int n;
        // 3、从输入流中读取数据，存放到byte数组中
        while((n = fileInputStream.read(bytes)) != -1)
        {
            // 4、创建String并且显示
            String s = new String(bytes, 0, n);
            System.out.println(s + "\r\n"); //换行
        }
        // 5、关闭输入流
        fileInputStream.close();
```

## 11、OutputStream、FilterOutputStream、BufferedOutputStream

25、BufferedOutputStream的作用？

- BufferedOutputStream等带缓冲区的实现
- 可以面频繁的磁盘读写，进而提高IO处理效率
- 这种设计利用了缓冲区，将批量数据进行一次操作
- 使用中一定要flush

## 12、Reader

26、Reader/Writer的作用？

- Reader/Writer则是用于操作字符
- 增加了字符编解码等功能
- 适用于从文件中读取或者写入文本信息等操作
- 本质上计算机操作的都是字节（不管是网络通信还是文件读取），Reader/Writer相当于构建了应用逻辑和原始数据之间的桥梁

## 13、InputStreamReader、FileReader

27、FileReader读取文件中的数据

```java
 // 1、创建文件
        File file = new File("d:\\a.txt");
        // 2、创建输入流(字符流)
        FileReader fileReader = new FileReader(file);
        char[] chars = new char[1024];
        int n;
        // 3、从输入流中读取数据，存放到byte数组中
        while((n = fileReader.read(chars)) != -1)
        {
            // 4、创建String并且显示
            String s = new String(chars, 0, n);
            System.out.println(s + "\r\n"); //换行
        }
        // 5、关闭输入字符流
        fileReader.close();
```

## 14、BufferedReader

28、BufferedReader的作用

- 保证Reader的子类
- 增加缓存区的功能

29、BufferedReader的使用

```java
// 1、创建FileReader
        FileReader fileReader = new FileReader(new File("d:\\a.txt"));
        // 2、创建BufferedReader，利用缓存区增强性能，并且提供readline()功能
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        // 3、从输入流中读取数据，存放到byte数组中
        String str;
        while((str = bufferedReader.readLine()) != null)
        {
            System.out.println(str); //换行
        }
        // 4、关闭BufferedReader
        bufferedReader.close();
```

## 15、Writer、PrintWriter

30、PrintWriter的作用

- 文本输出流，以格式化的形式，打印数据

31、PrintWriter的使用

```java
// 1、创建PrintWriter
        PrintWriter printWriter = new PrintWriter(new File("d:\\a.txt"));
        // 2、向文件中写入数据。原来的所有数据会先删除。然后依次写入数据
        printWriter.append("Hello");
        printWriter.write("World!");
        printWriter.print("Godebye");
        // 3、刷新缓存区
        printWriter.flush();
        printWriter.close();
```

32、write、print、append之间的区别？

- 效果上没有区别，都是写入数据
- 返回值上会有区别，append()会返回PrintWriter，可以进行链式调用
- write和print都没有返回值
- print参数为(String)null，会打印出null
- write()参数为null,会有空指针异常

## 16、NIO(62)

通道是数据的载体，buffer是存储数据的地方，线程每次从buffer检查数据通知给通道

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/NIO.png" />

1、NIO的主要组成部分

- Buffer（缓冲区）
- Channel（通道）
- Selector（选择器）
- ChartSet

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/NIO%E7%BB%84%E6%88%90.png" />

### 16.1、Channel

2、Channel的作用？

- 类似在linux操作系统上的文件描述符
- 一种操作系统底层的重选ing
- 用来支持批量式IO操作

3、Channel是操作系统底层的一种抽象

- File或者Socket，通常被认为是比较高层次的抽象
- Channel是更加操作系统底层的一种抽象
- 是的NIO得意充分利用现代操作系统底层机制，获得特定场景的性能优化
- 例如，DMA（Direct Memory Access）等。
- 不同层次的抽象是相互关联的，Socket和Channel之间能相互获取

### 16.2、Buffer

4、Buffer的作用

- Buffer是NIO操作数据的基本功能
- Java为每种原始数据类型都提供了Buffer（布尔类型除外）
- 高效的数据容器

5、Buffer的分类（7中）

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/buffer%E7%9A%84%E4%BD%9C%E7%94%A8.png" />

6、Buffer的基本属性

| 基本属性         | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| capcity(容量)    | Buffer的大小，也就是数组的长度                               |
| position（位置） | 对数据进行操作的起始位置                                     |
| limit（上界）    | 操作的限额。读取操作，limit就是所能容纳数据的上限；写入操作，limit就是设置为容量或者容量以下的可写额度 |
| mark（标记）     | 上一次position的位置，默认-1                                 |

7、Buffer的创建

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(10);
```

- capcity = 10 （容量）
- position = 0 ，会从第一个数据操作。
- limit = 10 操作的数据不能超过容量
- mark = -1 （默认值）

8、读取数据到Buffer中

```java
socketChannel.read(byteBuffer);
```

- position会随着read操作而不断增大，但不会超过limit

9、buffer.flip：反转操作，用于读取之前写入的数据

```java
byteBuffer.flip();
```

- 如反转前：position = 10，limit = 20
- flip后：limit = 10（position的旧值），position = 0 （复位到0）

10、从Buffer中读取数据

```java
socketChannel.write(buffer);
```

- 和read类似
- 随着操作，buffer中的position会逐渐增加，接近limit（但不会超过）

11、buffer.rewind：重读数据

- limit保持不变
- position = 0

## 17、ByteBuffer

12、ByteBuffer是什么？

- NIO中使用的Byte Buffer
- 包含两个实现方法：
  1. HeapByteBuffer 基于Java堆的实现
  2. DirectByteBuffer：堆外的实现方法，采用的unsafe API

13、从Channel中读取数据到ByteBuffer中

```java
byteBuffer = ByteBuffer.allocate(N);
//读取数据，写入byteBuffer
socketChannel.read(byteBuffer);

// 翻转，才能打印出来
byteBuffer.flip();
System.out.println("receive msg from client: "+Charset.defaultCharset().decode(byteBuffer.asReadOnlyBuffer()).toString());
```

14、向Channel中写入数据

```java
socketChannel.write(Charset.defaultCharset().encode("Hello World!"));
```

## 18、flip

15、ByteBuffer.flip()

- 进行翻转。将limit设置到position，然后将position复位为0
- 从Channel中read后，立即用于写数据

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
// 1、读取到数据
socketChannel.read(byteBuffer);
// 2、翻转
byteBuffer.flip();
// 3、发送给Client
socketChannel.write(byteBuffer);
```

## 19、Direct、Heap

16、Buffer.isDirect()有什么用？

```java
public abstract boolean isDirect()
```

- 抽象方法
- 用于判断具体Buffer是属于`堆内Buffer(Heap)`还是`堆外Buffer(Direct)`

17、如何创建堆外的Buffer？

- 使用allocateDirect()方法创建
- 只有ByteBuffer可以调用allocateDirect()创建堆外Buffer

```java
public static ByteBuffer allocateDirect(int capacity) {
    return new DirectByteBuffer(capacity);
}
```

18、如何创建堆内的Buffer？

- allocate()方法创建
- 所有Buffer都可以创建在堆内

```java
// ByteBuffer.java
public static ByteBuffer allocate(int capacity) {
    if (capacity < 0)
        throw new IllegalArgumentException();
    return new HeapByteBuffer(capacity, capacity);
}
```

```java
// IntBuffer.java
public static IntBuffer allocate(int capacity) {
    if (capacity < 0)
        throw new IllegalArgumentException();
    return new HeapIntBuffer(capacity, capacity);
}
```

```java
// LongBuffer.java
public static LongBuffer allocate(int capacity) {
    if (capacity < 0)
        throw new IllegalArgumentException();
    return new HeapLongBuffer(capacity, capacity);
}
```

19、所有的Buffer都可以选择创建在堆内或者堆外？

不准确

- 只有ByteBuffer可以调用allocateDirect()创建Direct Buffer（堆外）
- 其他类型Buffer没有该方法，但是也有相关类DirectCharBuffers等

20、堆内Buffer底层是如何实现的？

- 共七种Buffer：ByteBuffer、IntBuffer、LongBuffer等
- 内部就是对应的数组：byte数组、int数组、long数组等
- position、limit、mark、capacity的赋值，都是在基类Buffer的构造方法中执行

21、使用堆内Buffer操作相关的api，jdk会额外进行Direct Buffer缓存

- 使用堆内Buffer操作相关的api，jdk会将其复制为Direct buffer，并且在线程内部进行缓存。
- 早期jdk对Direct Buffer的缓存大小没有限制，但是容易出现OOM，后续jdk进行了限制
- 因此建议：尽量不要使用堆内的ByteBuffer操作Channel类api

## 20、MappedByteBuffer

22、DirectByteBuffer是什么？

- 继承自抽象类MappedByteBuffer
- 实现了DirectBuffer接口
- Direct-堆外相关的类都无法再JDK之外去引用
- 底层利用了unsafe_allocatememory

23、MappedByteBuffer的内部原理

- 将文件按照指定大小，直接映射为内存区域
- 程序访问该内存时，可以直接操作文件的数据
- 直接将数据拷贝到了用户控件，从而省去了将数据从内核空间向用户控件传输的损耗
- 本质上是一种Direct Buffer

24、MappedByteBuffer会影响NIO性能？

- 错误观点：NIO如果使用不当，速度会不传统IO慢几十倍，比如用MappedByteBuffer将文件映射到内存时
- 因为本质是节省了上下文切换的性能开销，性能应该更好

25、内存映射的效率比系统调用read、write还要高？

- read、write作为系统调用，将数据拷贝到内存中，需要经过两次拷贝：磁盘文件到内核缓存区，内核缓存区到用户空间缓存区。
- 内存映射，直接将文件数据从硬盘拷贝到了用户控件，只有一次数据拷贝
- NIO中直接内存映射到Buffer相当于直接在内存中存取数据，不需要经过内核态的缓冲区，性能更高

26、MappedByteBuffer的创建

1-实例

```java
// 只读、文件的起始位置10、map的size为30-最大位置是40
fileChannel.map(READ_ONLY, 10, 30);
```

2-map()方法

```java
public abstract MappedByteBuffer map(MapMode mode, // 模式
                                     long position, //从文件的position位置开始进行map映射
                                     long size) //map映射的最大尺寸
```

3-Mode有三种：只读、可写可读、写时复制

```
 // read-only：只读
public static final MapMode READ_ONLY;

// read/write：可读可写
public static final MapMode READ_WRITE;

// private (copy-on-write): 私有模式，写时进行拷贝。
public static final MapMode PRIVATE;
```

27、copy-on-write是什么意思？（COW）

- 写时拷贝技术-COW

28、DirectBuffer接口有什么用？

内部定义了三个方法

```java
public interface DirectBuffer {
    long address();
    Object attachment();
    Cleaner cleaner();
}
```

## 21、性能开销

29、DirectBuffer的性能优势？为什么会有性能优势？

- 实际使用中，Java会尽量对Direct Buffer只做本地IO操作
- 对于很多大数据量的IO密集操作，性能会比较高
- Direct Buffer生命周期内内存地址都不会再发生改变，因此内核可以安全的进行访问，IO操作会好高效。（本质就是寻址简单，跟锁没关系）
- 减少了Heap堆内对象存储时的维护工作，访问效率会更高

30、为什么Direct Buffer生命周期内内存地址都不会在发生改变，因此IO操作会很高效？是否是因为没有锁竞争？

- 本质就是寻址简单
- 跟锁完全没有关系

31、DirectBuffer的性能缺点？什么场景下才适合使用DirectBuffer？

- DirectBuffer在创建和销毁中，相比Heap Buffer会有额外的开销
- 适合长期使用，数据较大的场景

32、Direct Buffer（堆外）比Heap Buffer更高效，所以应该尽可能都用Direct Buffer？

- 短期使用、数据量较少时还是堆内Heap Buffer更好一些

## 22、垃圾回收

33、Direct Buffer对内存和JVM参数的影响

- 不在堆上，Xmx之类的参数，不能影响Direct Buffer等堆外成员所使用的内存额度
- 堆外Buffer设置内存额度的JVM参数：-xx:MaxDirectMemorySize=512M
- 计算Java可以使用的内存大小，除了需要考虑堆内，还需要考虑DirectBuffer等堆外元素

34、Direct Buffer 什么时候会被垃圾回收？

- 实际无法预测
- 依赖于cleanner
- 一般是延迟到full GC时期，快满时会被System.gc()触发ref处理

35、Java 可使用的内存大小只和堆有关？

错误

- 不仅需要考虑Heap
- 还需要考虑堆外元素

36、如果出现内存不足，可能有哪些原因？

- 需要考虑堆外内存占用

37、垃圾回收是否会回收Direct Buffer？Direct Buffer是如何回收的？

绝大部分GC都不会主动收集Direct Buffer

- Direct Buffer的垃圾回收是基于Cleaner机制和PlantomReference-虚引用、幻想引用
- Direct Buffer本身不是public类型，内部具有一个Deallocator负责销毁逻辑
- 其销毁主要是在full GC的时候，使用不当会OOM

38、Direct Buffer垃圾回收上的注意点

- 应用程序中，要显式地调用System.gc()来强制出发GC
- 在大量使用Direct Buffer的时候，主动去调用释放方法（Netty框架，实现在PlatformDependent中）
- 重复使用Direct Buffer

39、Direct Memory一定不会引起Full GC，只有在Full GC和调用System.gc()时才会去回收？

- 不是，还是利用sun.misc.Cleaner
- 但是具体实现有瑕疵，进场需要依赖System.gc()
- 后续的jdk版本有改进

40、如何跟踪和诊断Direct Buffer的内存占用？

- 通常的垃圾回收日志不会包含Direct Buffer的信息
- JDK8之后，可以使用Native Memory Tracking（NMT）特性进行诊断
- NMT的参数：-xx:NativeMemoryTracking=(summary | detail)
- 激活NMT通常会导致JVM出现5%~10%的性能下降

41、NMT可以在运行时采用命令进行交互式对比

1-打印NMT信息

```java
// 打印NMT信息
jcmd <pid> VM.native_memory detail
```

2-进行baseline，并且对比分配内存变化

```java
// 进行baseline
jcmd <pid> VM.native_memory baseline

// 对比分配内存变化
jcmd <pid> VM.native_memory detail.diff
```

3-输出结果的Internal部分会包含Direct Buffer内存使用情况

```java
-Internal (reserved=679KB +4KB, committed=679KB +4KB)
          (malloc=615KB +4KB #1571 +4)
          (mmap: reserved=64KB, committed=64KB)
```

4-底层利用了unsafe_allocatememory,但是本质并不是JVM内部使用的内存，在JDK11之后，将其分类在other部分

## 23、Selector

42、Selector的作用

- 是NIO实现多路复用的基础
- 它提供了一种高效的机制，可以检测到注册在Selector上的多个Channel中，是否有Channel处于就绪状态，进而实现了单线程对多Channel的高效管理
- Selector也是基于底层操作系统机制的，不同模式，不同版本都存在区别
- Linux上依赖于epoll
- windows上NIO2（AIO）模式则是依赖于iocp

43、Linux中的epoll是什么

epoll 是Linux内核中的一种可扩展IO事件处理机制，最早在 Linux 2.5.44内核中引入，可被用于代替POSIX select 和 poll 系统调用，并且在具有大量应用程序请求时能够获得较好的性能（ 此时被监视的文件描述符数目非常大，与旧的 select 和 poll 系统调用完成操作所需 O(n) 不同， epoll能在O(1)时间内完成操作，所以性能相当高），epoll 与 FreeBSD的kqueue类似，都向用户空间提供了自己的文件描述符来进行操作。

44、Windows中的iocp是什么?

IOCP模型属于一种通讯模型，适用于Windows平台下高负载服务器的一个技术。在处理大量用户并发请求时，如果采用一个用户一个线程的方式那将造成CPU在这成千上万的线程间进行切换，后果是不可想象的。而IOCP完成端口模型则完全不会如此处理，它的理论是并行的线程数量必须有一个上限-也就是说同时发出500个客户请求，不应该允许出现500个可运行的线程。目前来说，IOCP完成端口是Windows下性能最好的I/O模型，同时它也是最复杂的内核对象。它避免了大量用户并发时原有模型采用的方式，极大的提高了程序的并行处理能力。　

## 24、SelectionKey

45、SelectionKey是什么？

- 表示`SelectableChannel`在Selector中注册的句柄/标记
- `serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);`会返回注册事件的句柄。

46、一个Selector对象包含三种类型的SelectionKey集合

|               |                                                             |                         |
| ------------- | ----------------------------------------------------------- | ----------------------- |
| all-keys      | 当前所有想Selector注册的Channel的句柄（SelectionKey）的集合 | selector.keys()         |
| selected-keys | 相关事件已经被Selector捕获的SelectionKey                    | selector.selectedKeys() |

cancelled-keys	已经被取消的SelectionKey的结合	无API

47、SelectionKey何时被新建？何时会被加入到Selector的all-keys集合中？

- Channel注册到Selector中时，会新建一个SelectionKey，然后加入到all-keys集合中
- serverSocketChannel.register(selector,xxx)

48、SelectionKey对象何时会被遗弃（加入到cancelled-keys集合中）？

Selectionkey相关的Channel被关闭

调用了SelectionKey.cannel()方法

## 25、CharSet

49、Charset的作用

提供Unicode字符串定义

NIO也提供了相应的编解码器等

例如，通过下面的方式将字符串转换到ByteBuffer

```java
Charset.defaultCharset().encode("Hello world!"));
```

50、ByteBuffer转换为String

```java
Charset charset = Charset.defaultCharset();
// asReadOnlyBuffer将Buffer复制一份出来。
CharBuffer charBuffer = charset.decode(byteBuffer.asReadOnlyBuffer());
String string = charBuffer.toString();
```

## 26、多路复用

51、为什么需要多路复用

- 传统IO是一个线程处理一个链接
- 采用多路复用可以一个线程处理多个链接

52、NIO多路复用的局限性

- 当有IO请求在数据拷贝阶段
- 由于资源类型过于庞大，会导致线程长期阻塞
- 造成性能瓶颈

## 27、Scatter/Gather

53、NIO的Scatter/Gather机制是什么？

- 作为一个强大的工具，将数据的分散和聚集的任务委托给操作系统来完成
- Scatter：将读取到的数据分开放置到多个存储桶中（Bucket）
- Gather：将不同的数据区块合并成一个整体

54、如何在Channel读取时，将不同片段写入到对应的Buffer中（类似二进制消息拆分为消息头、消息体）？可以采用NIO的什么机制？

- 可以采用NIO分散-Scatter机制来写入不同Buffer
- 但是需要请求头的长度固定

```java
// 消息头
ByteBuffer header = ByteBuffer.allocate(128);
// 消息体
ByteBuffer body = ByteBuffer.allocate(1024);

// 从channel中读取不同片段
ByteBuffer[] bufferArray = {header, body}; channel.read(bufferArray);
```

## 28、NIO 2

55、NIO 2

- Java7引入了NIO 2
- 提供 一种额外的异步IO模式
- 利用事件和回调，处理Accept、Read等操作

56、NIO 2也不仅仅是异步

57、Future

58、CompletionHandler

59、Reactor和Proactor模式需要和Netty主题一起

60、NIO和NIO2的类似处

- AsynchronousServerSocketChannel对应ServerSocketChannel
- AsynchronousSocketChannel对应SocketChannel

61、NIO2的局限性

## 29、AsynchronousServerSocketChannel

62、AsynchronousServerSocketChannel进行网络请求

```java
// 1、创建AsynchronousServerSocketChannel
AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open()){
// 2、绑定IP和端口
serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));

// 3、为异步操作，指定CompletionHandler回调。
serverSocketChannel.accept(serverSocketChannel, new CompletionHandler<AsynchronousSocketChannel, AsynchronousServerSocketChannel>() {
        @Override
        public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) {
               serverSocketChannel.accept(serverSocketChannel, this);
            handleRequest(result);
        }

        @Override
        public void failed(Throwable exc, AsynchronousServerSocketChannel attachment) {

        }});
```

## 30、网络IO（13）

## 31、IO/BIO

1、Socket简单实现客户端和服务端通信

1-服务端：建立ServerSocket，等待客户端连接，然后处理数据

```java
public class DemoSocketServer extends Thread{
    private ServerSocket serverSocket;
    public int getPort(){
        return serverSocket.getLocalPort();
    }
    @Override
    public void run() {
        try {
            // 1、服务端启动ServerSocket，端口=0，表示自动绑定一个空闲端口
            serverSocket = new ServerSocket(0);
            while (true){
                // 2、阻塞等待一客户端的连接
                Socket socket = serverSocket.accept();
                // 3、处理客户端(新建一个线程)
                RequestHandler requestHandler = new RequestHandler(socket);
                requestHandler.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            // 任何情况下都要保障Socket资源关闭。
            if(serverSocket != null){
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    // 客户端请求的Handler
    public static class RequestHandler extends Thread{
        private Socket mSocket;
        RequestHandler(Socket socket){
            mSocket = socket;
        }
        @Override
        public void run() {
            try {
                // 1、Socket的输出流来创建printWriter
                PrintWriter printWriter = new PrintWriter(mSocket.getOutputStream());
                // 2、写入数据
                printWriter.println("Hello World!");
                printWriter.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

2-客户端（简单的打印数据）：借助try-with-Resources，利用Reader去读取数据

```java
// 客户端
public class Main {
    public static void main(String[] args) throws IOException {
        DemoSocketServer server = new DemoSocketServer();
        server.start();
        // 1、Socket客户端，绑定Server端Host地址，和Server端的端口。(这边是本机)
        try (Socket client = new Socket(InetAddress.getLocalHost(), server.getPort())) {
            // 2、通过客户端的inpustream，创建Reader
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream()));
            // 3、从Reader中读取到数据，并且打印。
        }
    }
}
```

2、线程池改进服务器

需要减少线程频繁创建和销毁的开销

```java
// 线程池
private Executor mExecutor;
@Override
public void run() {
    try {
        serverSocket = new ServerSocket(0);
        // 1、创建线程池：只有核心线程数，没有非核心线程数。任务队列无限。空闲线程会立即停止
        mExecutor = Executors.newFixedThreadPool(8);
        while (true){
            Socket socket = serverSocket.accept();
            RequestHandler requestHandler = new RequestHandler(socket);
            // 2、线程池进行处理
            mExecutor.execute(requestHandler);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }finally {
        // 任何情况下都要保障Socket资源关闭。
        if(serverSocket != null){
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

3、服务端采用线程池来提供服务的典型工作模式图

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BE%9B%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1.png" />

4、服务端采用线程池处理客户端连接的缺点？

- 连接数几百时，这种模式没有问题
- 但在高并发，客户端极其多的情况下，就会出现问题
- 线程你改下问切换的开销会在高并发是非常明显
- 这就是同步阻塞方式的地扩展性的体现

## 32、NIO

5、NIO优化服务端连接问题的实例

```java
public class NIOServer extends Thread{
    @Override
    public void run() {
        try (// 1、创建Selector。调度员的角色。
             Selector selector = Selector.open();
             /**-------------------------
              * 2、创建Channel。并进行配置。
              *---------------------------*/
             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()){
            // 1. 绑定IP和端口
            serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), 8888));
            // 2. 非阻塞模式。因为阻塞模式下是不允许注册的。
            serverSocketChannel.configureBlocking(false);
            /**-------------------------
             * 3、向Selector进行注册。通过OP_ACCEPT，表明关注的是新的连接请求
             *---------------------------*/
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            while(true){
                // 4、Selector调度员，阻塞在select操作。当有Channel有接入请求时，会被唤醒
                selector.select();
                // 5、被唤醒，获取到事件已经被捕获的SelectionKey的集合
                Set<SelectionKey> selectionKeys = selector.selectedKeys();
                Iterator<SelectionKey> iterator = selectionKeys.iterator();
                while (iterator.hasNext()){
                    SelectionKey selectionKey = iterator.next();
                    // 6、从SelectionKey中获取到对应的Channel
                    handleRequest((ServerSocketChannel) selectionKey.channel());
                    iterator.remove();
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 处理客户端的请求
    private void handleRequest(ServerSocketChannel socketChannel){

        // 1、获取到连接到该Channel Socket的连接
        try(SocketChannel client = socketChannel.accept()) {
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

            // 2、从客户端读取数据
            client.read(byteBuffer);

            // 3、翻转，用于读取显示和发送给服务器
            byteBuffer.flip();
            System.out.println("receive msg from client: "
                    +Charset.defaultCharset().decode(byteBuffer.asReadOnlyBuffer()).toString());

            // 4、向客户端中写数据
            client.write(byteBuffer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

测试

```java
public class Main {
    public static void main(String[] args) throws IOException {
        // 开启服务器
        NIOServer server = new NIOServer();
        server.start();

        // 1、Socket客户端，绑定Server端Host地址，和Server端的端口。(这边是本机)
        try (Socket client = new Socket(InetAddress.getLocalHost(), 8888)) {

            // 2、写入数据
            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
            bufferedWriter.write("I'm Client!");
            bufferedWriter.flush();

            // 3、读取数据
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(client.getInputStream()));
            System.out.println("receive msg from server: "+bufferedReader.readLine());
        }
    }
}
```

6、NIO在Socket编程上的优势

- 使用非阻塞的IO方式
- 支持IO多路复用
- 这些特性改变了传统网络编程中一个线程只能管理一个链接的情况，现在可以采用一个线程管理多个链接

7、NIO为什么比IO同步阻塞模式要更好？

- 同步阻塞模式需要多线程来处理多任务
- NIO利用了单线程轮询事件的机制，高效定位就绪的Channel
- 仅仅是Select阶段是阻塞的，可以避免大量客户端连接时，频繁切换线程带来的问题

8、NIO实现网络通信的工作模式图

9、NIO能解决什么问题

- 服务端多线程并发处理任务，即使使用线程池，高并发处理亦然会因为上下文切换，导致性能问题
- NIO是利用单线程轮询事件的机制，高效的去选择来请求连接的Channel仅提供服务

10、NIO的请求接收和处理都是在一个线程处理，如果有多个请求的处理顺序是什么？

- 多个请求会按照循序处理
- 如果一个处理具有耗时操作，会阻塞后续操作

11、NIO是否应该在服务端开启多线程进行处理？

- 可以

12、NIO遇到大量耗时操作该怎么办？

- 如果有大量耗时操作，那么整个NIO模型就不适用于这种场景。
- 过多的耗时操作，可以采用传统的IO方式

13、selector在单线程下的处理监听任务会成为性能瓶颈？

- 是的。单线程中需要一次处理监听。会导致性能问题
- 在你发数数万，数十万的情况下，会导致性能问题
- Doug Leaf推荐使用多个selector，在多个线程中并发监听Socket事件

## 33、文件拷贝（22）

1、Java有几种文件拷贝方式哪一种效率最高？

- java.io类库：为源文件构建FileInputStream，为目标文件构建FileOutputStream，从input中读取，写入output中
- java.nio类库：transferTo或者transferFrom
- java.nio.file.Files:Files.copy()进行拷贝

2、不同的文件复制方式，底层机制有什么不同？

3、用户态空间是什么？

- 用户态空间-User Space
- 用户态空间是普通应用和服务所使用的

4、内核态空间是什么

- 内核态空间-Kernel Space
- 操作系统内核、硬件驱动等都运行在内核态空间

5、读写操作的上下文切换是什么？

- 就是内核态和用户态之间的切换
- 使用输入流、输出流进行读写操作时，就在进行用户态和内核态之间的上下文切换
- 当读取数据时，会切换至内核态将数据从磁盘读取到内核缓存。然后再切换到用户态，将数据从内核缓存读取到用户缓存。
- 写入操作类似，仅仅是方向相反

6、读写操作时的性能问题是什么？如何去解决？

- 读写操作时，进行用户态和内核态的上下文切换，会带来额外的开销，从而降低IO效率
- 基于NIO transferTo的实现方式，在Linux和Unix上，会用到零拷贝技术
- 数据传输不再需要用户态参与，节省了上下文切换的开销和不必要的内存拷贝，尽鹅儿可能提高应用拷贝性能。

为什么零拷贝（zero-copy）可能有性能优势？

- 不再需要用户态和内核态的切换
- 减少 从内核缓存拷贝到用户缓存的这些不必要的内存拷贝
- 原来是4次拷贝：磁盘-》内核缓存，内核缓存-》用户缓存，用户缓存-》内核缓存，内核缓存-》磁盘。
- 零拷贝只有2次拷贝：磁盘-内核缓存，内核缓存-》磁盘

8、NIO transferTo的实现方式

- 会采用零拷贝技术
- transferTo不仅仅用在文件拷贝中，也能用于读取磁盘文件，然后Socket进行发送。同样性能有很大优势

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/transferTo%E6%8A%80%E6%9C%AF.png" />

9、为什么copy要设计成需要进行上下文切换的方式？为什么不和nio的transfer一样设计为不要用户态切换的开销

- 大部分工作需要用户态
- transfer是特定场景而不是通用场景

## 34、BIO的方式拷贝文件

10、利用javaio的InputStream和OutputStream进行文件拷贝

1-实现文件拷贝

```java
 /**========================================
     * java.io: 实现文件复制
     * @param src 源文件
     * @param dst 目标文件
     *=======================================*/
    public static void copyFileByIO(File src, File dst){
        try(InputStream inputStream = new FileInputStream(src);
            OutputStream outputStream = new FileOutputStream(dst)){

            byte[] buffer = new byte[1024];
            int length;
            // 读取数据到byte数组中，然后输出到OutStream中
            while((length = inputStream.read(buffer)) > 0){
                outputStream.write(buffer, 0, length);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

2-测试程序

```java
File src = new File("D:\\src.txt");
File dst = new File("D:\\dst.txt");
copyFileByIO(src, dst);
```

## 35、NIO的方式拷贝文件

11、利用NIO实现文件的拷贝

```java
/**===================================
 * java.nio: 实现文件复制
 * @param src 源文件
 * @param dst 目标文件
 *===============================*/
public static void copyFileByChannel(File src, File dst){
    // 1、获取到源文件和目标文件的FileChannel
    try(FileChannel srcFileChannel  = new FileInputStream(src).getChannel();
        FileChannel dstFileChannel = new FileOutputStream(dst).getChannel()){
        // 2、当前FileChannel的大小
        long count = srcFileChannel.size();
        while(count > 0){
            /**=============================================================
             *  3、从源文件的FileChannel中将bytes写入到目标FileChannel中
             *     1. srcFileChannel.position(): 源文件中开始的位置，不能为负
             *     2. count: 转移的最大字节数，不能为负
             *     3. dstFileChannel: 目标文件
             *==============================================================*/
            long transferred = srcFileChannel.transferTo(srcFileChannel.position(),
                    count, dstFileChannel);
            // 4、传输完成后，更改源文件的position到新位置
            srcFileChannel.position(srcFileChannel.position() + transferred);
            // 5、计算出剩下多少byte需要传输
            count -= transferred;
        }

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

测试

```java
File src = new File("D:\\src.txt");
File dst = new File("D:\\dst.txt");
// nio拷贝
copyFileByChannel(src, dst);
```

12、Nio的transferTo一定会快于BIO吗？

- 不一定，需要看实际情况

## 36、Files.copy的方式拷贝文件

13、利用Files.copy()进行文件拷贝

```java
Path srcPath = Paths.get("D:\\src.txt");
Path dstPath = Paths.get("D:\\dst.txt");
try {
  // 进行拷贝，CopyOption参数可以没有
    Files.copy(srcPath, dstPath);
} catch (IOException e) {
    e.printStackTrace();
}
```

14、Files.copy()有哪4种方法？

1-文件间进行copy

```
public static Path copy(Path source, Path target, CopyOption... options);
```

2-从输入流中copy到文件中

```
public static long copy(InputStream in, Path target, CopyOption... options);
```

3-从文件中copy到输出流

```
public static long copy(Path source, OutputStream out);
```

4-从输入流copy到输出流中

```
private static long copy(InputStream source, OutputStream sink);
```

15、Path copy(Path, Path, CopyOption…)源码分析

```java
public static Path copy(Path source, Path target, CopyOption... options)
{
    FileSystemProvider provider = provider(source);
    if (provider(target) == provider) {
        // same provider-同种文件系统拷贝
        provider.copy(source, target, options);
    } else {
        // different providers-不同文件系统拷贝
        CopyMoveHelper.copyToForeignTarget(source, target, options);
    }
    return target;
}
```

16、FileSystemProvider是什么？如何提供文件系统的？

- 文件系统的服务的提供者
- 是一个抽象类
- 内部通过ServiceLoader机制加载一系列文件系统，然后提供服务
- 文件系统的实际逻辑是在JDK内部实现的，可以在JDK源码中搜索FileSystemProvider、nio，可以定位到sun/io/fs，因为NIO底层和操作系统紧密相连，所以每个平台都有自己部分特有的文件系统
- Unix平台会定位到UnixFileSystemProvider-》UnixCopyFile.Transfer->UnixCopyFile.c

```java
// FileSystemProvider.java
private static List<FileSystemProvider> loadInstalledProviders() {
    //加载所有已经安装的文件系统服务的提供者
    List<FileSystemProvider> list = new ArrayList<FileSystemProvider>();
    ServiceLoader<FileSystemProvider> sl = ServiceLoader
        .load(FileSystemProvider.class, ClassLoader.getSystemClassLoader());
    //xxx
}
```

17.平台特有的文件系统服务提供者：FileSystemProvider

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/08.JAVA%E5%9F%BA%E7%A1%80/01.JavaIO/%E5%B9%B3%E5%8F%B0%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85.png" />

18、copy（InputStream，OutputStrea）源码分析

- 直接进行InputStream和OutputStream的read和write操作，本质和一般IO操作是一样的
- 也就是用户态的读写

```java
private static long copy(InputStream source, OutputStream sink)
{
    long nread = 0L;
    byte[] buf = new byte[BUFFER_SIZE];
    int n;
    while ((n = source.read(buf)) > 0) {
        sink.write(buf, 0, n);
        nread += n;
    }
    return nread;
}
```

19、copy（InputStream，Path，CopyOption...）源码分析

- 本质调用的copy(InputStream,OutputStream)方法

```java
public static long copy(InputStream in, Path target, CopyOption... options)
{
    // xx省略代码xx
    Objects.requireNonNull(in);
    OutputStream ostream;

    // 1、通过target的Path获取到OutputStream
    ostream = newOutputStream(target, StandardOpenOption.CREATE_NEW,
                                          StandardOpenOption.WRITE);

    // 2、然后还是直接调用copy(InputStream, OutpuStream)的方法进行数据拷贝。
    try (OutputStream out = ostream) {
        return copy(in, out);
    }
}
```

20、copy(Path,OutputStream)源码分析

本质调用的copy(InputStream,OutputStream)源码分析

```java
public static long copy(Path source, OutputStream out) throws IOException {
    //1、输出流不为Null
    Objects.requireNonNull(out);
    //2、本质调用的copy(InputStream, OutputStream)方法
    try (InputStream in = newInputStream(source)) {
        return copy(in, out);
    }
}
```

21、JDK10中Files.copy()实现的轻微改变：InputStream.transferTo

- copy(Path path,CopyOption...)内部机制内变化
- 剩余copy()方法，将输入流、输出流的读写封装到了方法中：InputStream.transferTo()，也就是处于用户态的读写

```java
public long transferTo(OutputStream out) throws IOException {
        Objects.requireNonNull(out, "out");
        long transferred = 0;
        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
        int read;
        //IO读写操作
        while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) >= 0) {
            out.write(buffer, 0, read);
            transferred += read;
        }
        return transferred;
}
```

## 37、拷贝性能

22、如何提升类似拷贝等IO操作的性能？

- 合理使用缓存等机制，合理减少IO次数
- 使用transferTo等机制，减少上下文切换和额外的IO操作
- 减少不必要的转换过程，如：编解码、对象序列化和反序列化、操作文本文件或者网络通信，如果不是要使用文本信息，可以直接传输二进制信息。而不是传输字符串

## 38、扩展知识

1、NIO提供的高性能数据操作方式是基于什么原理，如何使用？

2、从开发者的角度来看，NIO自身实现存在哪些问题？有什么改进的想法吗？

- NIO的多路复用存在系统瓶颈

3、开启一个线程需要消耗多少内存？（32位和64位）



























































































