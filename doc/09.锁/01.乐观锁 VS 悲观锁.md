# 01.乐观锁 VS 悲观锁

乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度，在Java和数据库中都有此概念对应的实际应用。

## 1.乐观锁

顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，锁不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，乐观锁在Java中是通过使用无锁编程来实现，最常用的是采用CAS算法，Java 元子类中的递增操作就是通过CAS自旋来实现的。

CAS全称Copmare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有现成被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的元子类就是通过CAS来实现了乐观锁。

简单来说，CAS算法有3个操作数：

需要读写的内存值V。

进行比较的值A

要写入的新值B。

**当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。**这是一种乐观锁的思路，它相信在它修改之前，没有其他线程去修改它；而**Synchronized是一种悲观锁，它认为在它修改之前，一定会有其他线程去修改它，悲观锁效率低。**

## 2.悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞知道它拿到锁。

传统的MySQL关系型数据库里边就用了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在操作之前先上锁。

再比如上面提到的Java的同步synchronize关键字的实现就是典型的悲观锁。

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/09.%E9%94%81/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81.png" />

**悲观锁适合写操作多的场景**，现价所可以保证写操作时数据正确。

**乐观锁适合读操作多的场景**，不加锁的特点能够使其杜曹佐的性能大幅提升。

## 3.MySQL行锁、表锁、悲观锁、乐观锁的特点与应用

我们再操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）。如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，锁的冲突也是影响数据库并发访问性能的一个重要因素，从这一角度来说，锁对于数据库而言就显得尤为重要

### 3.1 MySQL锁概述

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。

比如：

- MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）
- InnoDB存储引擎既支持行级锁（row-level locking）,也支持表级锁，但默认情况下是采用行级锁。

**MySQL主要的两种锁的特性可大致归纳如下：**

<img src="https://raw.githubusercontent.com/yulongshuai878/myTechnology/master/pic/09.%E9%94%81/MySQL%E9%94%81.png" />

- 表级锁：开销小，加锁快；不会出现死锁（因为MyISAM会一次性获得SQL所需的全部锁）；锁定粒度大，发生锁冲突的时候概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低并发度也高。
- 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般

3.2 行锁和表锁

1. 主要是针对锁粒度划分，一般分为：行锁，表锁，库锁

   1. 行锁：访问数据库的时候没锁定整个行数据，防止并发错误
   2. 表锁：访问数据库的时候，锁定整个表数据，防止并发错误。

2. 行锁和表锁的区别：

   表锁：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低。

   行锁：开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。

## 4.共享锁

共享锁指的是对于多个不同的食物，对统一个资源共享同一个锁。相当于对于同一把们，它拥有对个钥匙一样。就像这样，你家有一个大门，大门的钥匙有好几把你们口可以通过着吧钥匙进入你们家，这就是所谓的共享锁。

对于悲观锁，一般数据库已经实现了，共享锁也属于悲观锁的一种，那么共享锁在MySQL中时通过什么命令来调用呢。通过在执行语句后面加上lock in share mode 就代表对某些资源嘉善共享锁了。

## 5.什么时候用表锁？

对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁旺旺是我们之所以选择InnoDB表的理由。但是在个别特殊事务中，也可以考虑使用表级锁。

第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。

第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁，减少数据库因事务回滚带来的开销。

当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。

表锁和行锁应用场景：

表级锁使用与并发性不高，以查询为主，少量更新的应用，比如小型的web应用；

行级锁适合于高并发环境下，对事务完整性要求较高的系统，比如在线事务处理系统